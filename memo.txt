@ 쓰레드세잎일 경우 대체로 동기화 오버헤드로 성능에 영향

@ 체이닝을 사용할 경우 보통 this를 활용(아니면 추가코딩 가능성이 올라감 / chining패키지 참고)

@ 일반적으론 자바 코드 최적화보단 네트워크 호출 한 번을 줄이는게 훨씬 나음

@ 캡슐화 관점에선 계산로직은 일반적으로 return문이나 get을 사용하여 필드값을 노출하기보단 클래스 내부에서 진행되는 것이 나음

# object
- 동등성 비교를 위해선 반드시 오버라이딩(object 디폴트는 동일성) - 클래스마다 기준이 다르기에(대부분 인텔리제이 사용)

# 불변객체
- 자바에서 기본형 : 절대 변수간 값 공유 불가
- 캐싱, 쓰레드세잎, 엔티티 값 타입 이점
- 불변객체의 수정이 필요한 경우 메서드로 객체를 복사하여 제공 > 따라서 불변객체 사용시 값 반환에 주의(변수에 할당할 것)
> 수정메서드는 set보단 with를 많이 씀

# string
- 클래스별 toString 오버라이딩 확인 필요(CharArrayMain 참고)
- 자바9 이후 char[] > byte[]
- string 풀은 힙에 위치
- 문자열 비교는 항상 equals로 (EqualsMain2 참고)
> string으로 메서드를 만들때 참조(new String)일지 리터럴일지 모르므로

- 리터럴 +연산의 경우 컴파일 타임에 그냥 합쳐버려서 성능 최적화
- 변수 +연산의 경우 빌더로 바꿔 성능 최적화
- 웬만하면 +연산으로 되지만 루프에선 최적화가 힘듦
> 루프, 조건문에서 동적 조합에서 사용

# 래퍼 class
- 래퍼클래스는 불변, equals 사용, toString overrided
- 박싱의 경우 추후 optional 공부시 복습 필요
- 일반적으로 최근 최적화 < 유지보수를 중시

# Class class(예약어기에 clazz로 대체)
- 메타데이터를 다루는데 사용
- 대부분 동적 로딩을 주로 사용하는 리플렉션, 애노테이션에 사용

# system
- sys.exit는 웹에선 거의 금지


# enum
- ex02처럼 enum 멤버는 기본적으로 static final이며 런타임에서 인스턴스가 각각 생성
- 제한된 인스턴스 생성, 데이터 일관성 보장, switch문 사용가능
- static import 사용
- ordinal() 사용 지양(기존 순서가 다 밀려버림)
- 이미 상속되어 추가 상속 불가능

# util.Date
- 역사
1: calendar 도입
1.1: calendar 문제 / Joda-time lib 도입
1.8: Joda는 외부 lib / java.time 표준 api 도입
(jpa도 비슷 : Joda = Hibernate, time = jpa)
- 일반적으로 해외 서비스를 생각하면 ZonedDateTime을 씀(단순 offset이라면 다름)
- period 년월일 시간, duration 시분초 시간
- 모든 time 관련 클래스는 불변

